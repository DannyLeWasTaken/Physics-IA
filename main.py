# Reference used for simulation: https://docs.google.com/document/d/10sXEhzFRSnvFcl3XxNGhnD4N2SedqwdAvK3dsihxVUA/edit#
# Copper 	Cast Iron 	Clean and Dry 	1.05 	0.29
# Weight calculated by using: https://www.industrialmetalsupply.com/weight-calculator

from re import L
from struct import unpack
import pybullet
import time
import pybullet_data
import random
import math
import csv
import os

# DEFINE CONSTANTS
#https://stackoverflow.com/questions/4060221/how-to-reliably-open-a-file-in-the-same-directory-as-the-currently-running-scrip
__location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))


# CONFIGRUATION'
TIME_STEP = 1./240.
numberTrials = 5
rotations = [20,30,35,40,45,50,55,60,70,80]
REAL_TIME = False
UP_HILL = 5
DESIRED_DISTANCE = 1

recordedData = {}

def vectorMangitudes(vec1, vec2):
	# Determine magnitude in 3d space
	return math.sqrt(((vec1[0] - vec2[0])**2) + ((vec1[1] - vec2[1])**2) + ((vec1[2] - vec2[2])**2))

def getDegreesFromRadians(rad):
	return rad * (math.pi/180)

def generateRIU(min, max, decimals=1, unforseenpercent=10):
	#generateRandomIntegerUnforseen
	# generates a random number including an unforseen randomness to prevent predictability
	actualPercent = unforseenpercent / 100
	min *= decimals;
	max *= decimals;
	newMin = min + random.uniform(-(min * actualPercent), (min * actualPercent)) 
	newMax = max + random.uniform(-(max * actualPercent), (max * actualPercent)) 
	return random.uniform(newMin, newMax) / decimals

def generateInaccuracy(num, decimals=1, deviate=1, percentunforseen=10):
	return generateRIU(num - deviate, num + deviate, decimals, percentunforseen)

def generatePercentInaccuracy(num, decimals=1, percentdeviate=10, percentunforseen=10):
	actualPercent = percentdeviate/100
	return generateRIU(num - (num * actualPercent), num + (num * actualPercent), decimals, percentunforseen)

physicsClient = pybullet.connect(pybullet.GUI)
pybullet.setAdditionalSearchPath(pybullet_data.getDataPath())
pybullet.setTimeStep(TIME_STEP)
pybullet.setGravity(0,0,-9.81)
pybullet.planeId = pybullet.loadURDF("plane.urdf")

for rotation in rotations:
	recordedData[rotation] = []
	# Different motion
	for i in range(numberTrials):
		# Set up simulation
		simulationStart = time.time();
		simulationEnd = 0;
		simulationTime = 0
		simulationStep = 0
		cycleStart = 0
		continueSimulation = True
		startPos = None

		maxDistanceCanTravel = generateInaccuracy(DESIRED_DISTANCE, 4, 0.01, 20)
		inclineOrientation = pybullet.getQuaternionFromEuler((0, getDegreesFromRadians( generateInaccuracy(rotation, 1, 2, 10) ), 0))

		inclinePlaneId = pybullet.loadURDF("inclined_plane.urdf", (0,0,0), inclineOrientation)
		#pybullet.changeDynamics(inclinePlaneId, rollingFriction=0)
		pybullet.setCollisionFilterPair(inclinePlaneId, pybullet.planeId, -1, -1, 0)
		pybullet.changeDynamics(inclinePlaneId, -1, mass=0)

		rayResult = pybullet.rayTest((-UP_HILL,0,10000), (-UP_HILL,0,0))
		cubeStartPos = rayResult[0][3]
		cubeStartPos = (cubeStartPos[0], cubeStartPos[1], cubeStartPos[2] + 0.05)

		cubeId = pybullet.loadURDF("physics_block.urdf", cubeStartPos, inclineOrientation)


		inclineTransform = (0,0,0)
		quatrotation = pybullet.getQuaternionFromEuler((0,rotation,0));

		# Actually simulate
		while continueSimulation:

			cubePos, cubeOrn = pybullet.getBasePositionAndOrientation(cubeId)
			
			# Check if there is something underneath
			rayResult = pybullet.rayTest(cubePos, (cubePos[0] - 0.1, cubePos[1], cubePos[2] - 0.11))
			magnitude = vectorMangitudes(cubePos, rayResult[0][3])
			if magnitude and startPos == None:
				startPos = cubePos
				# Generate unforseen random force generated by a simulated hand
				# pybullet.applyExternalForce(cubeId, -1, cubePos, ( generateInaccuracy(0, 100, 0.2, 10), generateInaccuracy(0, 100, 0.2, 10), generateInaccuracy(0, 100, 0.2, 10) ), pybullet.WORLD_FRAME)
				# https://stackoverflow.com/questions/49639163/move-an-object-towards-a-target-in-pybullet
			
			if (time.time() - simulationStart)>=10:
				continueSimulation = False
				simulationEnd = 0
			elif (startPos != None and vectorMangitudes(startPos, cubePos) >= maxDistanceCanTravel):
				continueSimulation = False
				simulationEnd = time.time()

			simulationStep += 1
			simulationTime += TIME_STEP
			pybullet.stepSimulation()
			if REAL_TIME:
				time.sleep(1./480.)
		# Simulation stop, clean up!
		pybullet.removeBody(cubeId)
		pybullet.removeBody(inclinePlaneId)
		
		if simulationEnd != 0:
			print("===TRIAL REPORT===\nSimulation Trial: {trial}.\nAngle: {angle}, Delta T: {dt}\n===END REPORT===".format(trial = i + 1, angle = rotation, dt = simulationTime))
			recordedData[rotation].append(simulationTime)
		else:
			recordedData[rotation].append("N/A")

		print("===TRIAL REPORT===\nSimulation Trial: {trial}.\nAngle: {angle}, Delta T: {dt}\n===END REPORT===".format(trial = i + 1, angle = rotation, dt = (simulationEnd != 0 and simulationTime) or "N/A" ))


# https://stackoverflow.com/questions/42486764/python-creating-a-new-file-folder-in-the-same-directory-as-the-script
resultsDirectory = os.path.join(__location__, 'results')
roundedSimulation = round(simulationEnd)
csvDirectory = r'{base}/{timeStamp}.csv'.format(base=resultsDirectory, timeStamp=roundedSimulation)

if not os.path.exists(resultsDirectory):
	os.mkdir(resultsDirectory)

if not os.path.exists(csvDirectory):
	open("results\{}.csv".format(roundedSimulation), "x")

with open("results\{}.csv".format(roundedSimulation), 'w') as csvfile:
	writer = csv.writer(csvfile)
	fields = ["Rotation"]
	for x in range(numberTrials):
		fields.append("Trial {number}".format(number=x + 1))
	writer.writerow(fields)

	for key in rotations:
		row = recordedData[key]
		row.insert(0, str(key))
		writer.writerow(row)

pybullet.disconnect()